% !TEX root = ../partial-sdm.tex

Performance matters --- and has always mattered. If an experiment takes a few seconds, there is no point arguing whether we should try it. If it takes a few hours, maybe we should think first. If it takes a few days, it is more important to make a good plan. As SDM consumes a lot of both processor and memory resources, some experiments may take a long time.

Each scan a 1,000-bits SDM with 1,000,000 hard-locations executes $10^9$ bit compares through $10^9/64 = 15,625,000$ XORs and calls to the built-in popcount. So, 10,000 writes execute $10^{13}$ bit compares, while a 6-iterative reading executes $6 \cdot 10^{12}$ bit compares. The heatmap of Figure \ref{fig:cir-dist-10k-writes-kanerva} executed $3.05 \cdot 10^{15}$ bit compares. For comparison, the number of seconds since Jesus's birth is 63,639,648,000 = $6.36 \cdot 10^{10}$. The number of people who have ever lived on earth is estimated to be $1,08 \cdot 10^{11}$. There are approximtely $1.8 \cdot 10^{9}$ websites in the internet. A modern laptop can increment a counter $5 \cdot 10^{8}$ times per second. Hence, a naive implementation of SDM may take several hours to simply write 10,000 random bitstrings.

Amazon EC2 p3.2xlarge has generated the heatmap of Figure \ref{fig:cir-dist-10k-writes-kanerva} in 15 minutes and 3 seconds. It has compared $3.37 \cdot 10^{12}$ bits per second through $52.6 \cdot 10^{9} = 52.6 \text{ billion}$ XORs and popcounts per second. It is a great improvement when compared to the first versions of the code which took 16 hours to generate the same heatmap (and its memory use was already optimized and the computations were distributed in threads).

We have created a benchmark to be able to compare the performance in different devices. So, the same performance test was executable in our devices and the results were reported in tables and figures. The benchmark has 3 parts: (i) the first part consists of comparing the available OpenCL kernels to find which works best for that device; than (ii) the second part consists of comparing the linear scanner, the thread scanner, and the OpenCL scanners with the best kernel found in part one; finally, (iii) the third part consists of comparing read and write operations using the thread scanner and the OpenCL scanner with the best kernel. Each part was run for three SDM setups: (i) $n=1,000$, $r=451$, and $H=1,000,000$; (ii) $n=256$, $r=103$, and $H=1,000,000$; and (iii) $n=10,000$, $r=4850$, and $H=1,000,000$. The whole source code is available in the ``Performance test'' notebook \citep{sdmframework}. We would like to invite you to run this benchmark in your device and send us the results.

Our first device was a personal MacBook Pro Retina 13-inch Late 2013 with a 2.6GHz Intel core i5 processor, 6GB DDR3 RAM, and Intel Iris GPU. It was not possible to run the 10,000-bits in this device because there was no memory available --- it would use 37.25 GB of memory.

Our second device was an iMac Retina 5K 27-inch 2017 with a 3.8GHz Intel core i5 processor, 8GB DDR4 RAM, and a Radeon Pro 580 8G CPU. The complete results are presented in Figures \ref{fig:perf-imac-read-256}, \ref{fig:perf-imac-write-256}, \ref{fig:perf-imac-read-1000}, \ref{fig:perf-imac-write-1000}, \ref{fig:perf-imac-scan-256}, \ref{fig:perf-imac-scan-1000}, and \ref{fig:perf-imac-scan-10k} and Tables \ref{tab:perf-imac-256}, \ref{tab:perf-imac-1000}, and \ref{tab:perf-imac-10k}.

Beyond that, we were also running in state-of-the-art devices: (i) an Amazon EC2 p2.xlarge with Intel Xeon E5-2686v4 processor, 61GB DDR3 RAM, and NVIDIA K80 GPU, and (ii) an Amazon EC2 p3.2xlarge with Intel Xeon E5-2686v4 processor, 488GB DDR3 RAM, and NVIDIA Tesla V100 GPU.


\section{Kernels comparison}

OpenCL is a framework for writting software that executes in \emph{heterogeneous} devices \citep{munshi2009opencl}, like CPUs, GPUs, and other co-processor for hardware acceleration. Because they are heterogogeneous, they may differ a lot in architecture and performance, which means there is no one-size-fits-all kernel. The slower kernel for one device may be the fastest for another device, and it really happened in our case.

Our framework has 7 kernels available: single\_scan0, single\_scan1, single\_scan2, single\_scan3, single\_scan4, single\_scan5, single\_scan5\_unroll, and single\_scan6. Each scan uses a different algorithm to do exactly the same thing: calculate which hard-locations are inside the circle of the given bitstring. They differ in how they split the work between work-groups and how they explore the GPU architecture to obtain performance gains.

The difference in which kernel is the best depends also in the SDM setup. The best kernel for the 1,000-bits SDM in the MacBook Pro was single\_scan1 with average scan time of 13.22ms (Table \ref{tab:perf-macbook-1000}). But, for the 256-bits SDM in the same device, it was single\_scan0 with average scan time of 8.36ms (Table \ref{tab:perf-macbook-256}). The comparison of all kernels in MacBook Pro is available in Figures \ref{fig:perf-macbook-kernels-1000} and \ref{fig:perf-macbook-kernels-256}.


\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    single\_scan0 & 1000 & 42.36 & 23.60 \\
    single\_scan1 & 1000 & 75.63 & 13.22 \\
    single\_scan2 & 1000 & 21.14 & 47.28 \\
    single\_scan3 & 1000 & 30.24 & 33.06 \\
    single\_scan4 & 1000 & 24.79 & 40.32 \\
    single\_scan5 & 1000 & 31.73 & 31.51 \\
    single\_scan5\_unroll & 1000 & 36.28 & 27.55 \\
    single\_scan6 & 1000 & 25.32 & 39.48 \\
    \hline
\end{tabular}
\caption{MacBook Pro Retina 13-inch Late 2013 with a 2.6GHz Intel core i5 processor, 6GB DDR3 RAM, and Intel Iris GPU. Running an SDM with $n=1,000$ bits, $H=1,000,000$, and $r=451$.
\label{tab:perf-macbook-kernels-1000}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    single\_scan0 & 1000 & 119.49 & 8.36 \\
    single\_scan1 & 1000 & 95.82 & 10.43 \\
    single\_scan2 & 1000 & 42.58 & 23.48 \\
    single\_scan3 & 1000 & 39.19 & 25.51 \\
    single\_scan4 & 1000 & 23.58 & 42.39 \\
    single\_scan5 & 1000 & 40.94 & 24.42 \\
    single\_scan5\_unroll & 1000 & 43.91 & 22.77 \\
    single\_scan6 & 1000 & 23.70 & 42.18 \\
    \hline
\end{tabular}
\caption{MacBook Pro Retina 13-inch Late 2013 with a 2.6GHz Intel core i5 processor, 6GB DDR3 RAM, and Intel Iris GPU. Running an SDM with $n=256$ bits, $H=1,000,000$, and $r=103$.
\label{tab:perf-macbook-kernels-256}}
\end{table}

\begin{figure}[!htb]
\centering\includegraphics[width=\textwidth]{images02/performance/imac-scans-1000.png}
\caption{MacBook Pro Retina 13-inch Late 2013 with a 2.6GHz Intel core i5 processor, 6GB DDR3 RAM, and Intel Iris GPU. Kernel comparisons in a SDM with $n=1,000$, $H=1,000,000$ and $r=451$.
\label{fig:perf-macbook-kernels-1000}}
\end{figure}

\begin{figure}[!htb]
\centering\includegraphics[width=\textwidth]{images02/performance/imac-scans-1000.png}
\caption{MacBook Pro Retina 13-inch Late 2013 with a 2.6GHz Intel core i5 processor, 6GB DDR3 RAM, and Intel Iris GPU. Kernel comparisons in a SDM with $n=256$, $H=1,000,000$ and $r=103$.
\label{fig:perf-macbook-kernels-256}}
\end{figure}


\section{Scanners comparison}


It is interesting that which scanner is faster depends also on the SDM settings. In the iMac 2017, the faster scanner for a 1,000-bits SDM was the OpenCL, but for a 256-bit SDM was the threads. What happened here is that the OpenCL kernel chosen was a generic one which performs the scan for any SDM. It is always possible to optimize the OpenCL kernel to a specific setting, and it would be faster than the threads. By default, the framework chooses a generic kernel which we believe would be reasonable for the most common setups.
% TODO Run the optimized kernel and show the results.

Most of the time, the bottleneck of both the read and the write operations is the scanner. But we have optimized the OpenCL kernel so much for the iMac 2017 that scanner not the bottleneck anymore. In the writing operation, it took the same time to scan and to update the counters. It is impressive because it update, on average, 1,000 counters of 32-bit integers each, and it was as fast as (i) sending the command to the GPU, (ii) performing 1 billion bit compares, and (iii) downloading the response from the GPU.

Our conclusion is that, if one is really concerned about performance, one should fine tune the OpenCL kernel for one's GPU. It would always be faster than running in the CPU.


\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    single\_scan0 & 3000 & 199.62 & 5.00 \\
    single\_scan1 & 3000 & 252.64 & 3.95 \\
    single\_scan2 & 3000 & 218.38 & 4.57 \\
    single\_scan3 & 3000 & 271.15 & 3.68 \\
    single\_scan4 & 3000 & 247.28 & 4.04 \\
    single\_scan5 & 3000 & 268.29 & 3.72 \\
    single\_scan5\_unroll & 3000 & 276.70 & 3.6139983336130777 \\
    single\_scan6 & 3000 & 248.26 & 4.02 \\
    \hline
\end{tabular}
\caption{iMac Retina 5K 27-inch 2017 with a 3.8GHz Intel core i5 processor, 8GB DDR4 RAM, and a Radeon Pro 580 8G GPU. Running an SDM with $n=1,000$ bits, $H=1,000,000$, and $r=451$.
\label{tab:perf-imac-kernels-1000}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    single\_scan0 & 3000 & 329.71 & 3.03 \\
    single\_scan1 & 3000 & 347.42 & 2.87 \\
    single\_scan2 & 3000 & 261.73 & 3.82 \\
    single\_scan3 & 3000 & 268.16 & 3.72 \\
    single\_scan4 & 3000 & 223.18 & 4.48 \\
    single\_scan5 & 3000 & 265.59 & 3.76 \\
    single\_scan5\_unroll & 3000 & 263.24 & 3.79 \\
    single\_scan6 & 3000 & 228.92 & 4.36 \\
    \hline
\end{tabular}
\caption{iMac Retina 5K 27-inch 2017 with a 3.8GHz Intel core i5 processor, 8GB DDR4 RAM, and a Radeon Pro 580 8G GPU. Running an SDM with $n=256$ bits, $H=1,000,000$, and $r=103$.
\label{tab:perf-imac-kernels-256}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    single\_scan0 & 500 & 16.37 & 61.06 \\
    single\_scan1 & 500 & 22.24 & 44.96 \\
    single\_scan2 & 500 & 22.23 & 44.98 \\
    single\_scan3 & 500 & 78.92 & 12.67 \\
    single\_scan4 & 500 & 87.30 & 11.45 \\
    single\_scan5 & 500 & 79.43 & 12.58 \\
    single\_scan5\_unroll & 500 & 87.88 & 11.37 \\
    single\_scan6 & 500 & 91.21 & 10.96 \\
    \hline
\end{tabular}
\caption{iMac Retina 5K 27-inch 2017 with a 3.8GHz Intel core i5 processor, 8GB DDR4 RAM, and a Radeon Pro 580 8G GPU. Running an SDM with $n=10,000$ bits, $H=1,000,000$, and $r=4850$.
\label{tab:perf-imac-kernels-10k}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    single\_scan0 & 3000 & 1433.27 & 0.69 \\
    single\_scan1 & 3000 & 1822.51 & 0.54 \\
    single\_scan2 & 3000 & 1165.06 & 0.85 \\
    single\_scan3 & 3000 & 979.93 & 1.02 \\
    single\_scan4 & 3000 & 906.35 & 1.10 \\
    single\_scan5 & 3000 & 1049.21 & 0.95 \\
    single\_scan6 & 3000 & 958.50 & 1.04 \\
    \hline
\end{tabular}
\caption{EC2 p3.2xlarge 1000 bits
\label{tab:perf-imac-256}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Loops & Total time & Scans per second & Time per scan (ms) \\
    single\_scan0 & 3000 & 2729.58 & 0.36 \\
    single\_scan1 & 3000 & 2703.49 & 0.36 \\
    single\_scan2 & 3000 & 1354.12 & 0.73 \\
    single\_scan3 & 3000 & 1573.43 & 0.63 \\
    single\_scan4 & 3000 & 951.22 & 1.05 \\
    single\_scan5 & 3000 & 1598.69 & 0.62 \\
    single\_scan6 & 3000 & 986.06 & 1.01 \\
    \hline
\end{tabular}
\caption{EC2 p3.2xlarge 256 bits
\label{tab:perf-imac-256}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Loops & Total time & Scans per second & Time per scan (ms) \\
    single\_scan0 & 500 & 48.54 & 20.60 \\
    single\_scan1 & 500 & 202.34 & 4.94 \\
    single\_scan2 & 500 & 199.29 & 5.01 \\
    single\_scan3 & 500 & 164.66 & 6.07 \\
    single\_scan4 & 500 & 166.70 & 5.99 \\
    single\_scan5 & 500 & 186.26 & 5.36 \\
    single\_scan6 & 500 & 167.74 & 5.96 \\
    \hline
\end{tabular}
\caption{EC2 p3.2xlarge 10k bits
\label{tab:perf-imac-256}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Loops & Total time & Scans per second & Time per scan (ms) \\
    single\_scan0 & 3000 & 263.61 & 3.79 \\
    single\_scan1 & 3000 & 253.45 & 3.94 \\
    single\_scan2 & 3000 & 117.06 & 8.54 \\
    single\_scan3 & 3000 & 102.70 & 9.73 \\
    single\_scan4 & 3000 & 87.82 & 11.38 \\
    single\_scan5 & 3000 & 100.46 & 9.95 \\
    single\_scan6 & 3000 & 88.21 & 11.33 \\
    \hline
\end{tabular}
\caption{EC2 p2.xlarge 1000 bits
\label{tab:perf-imac-256}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Loops & Total time & Scans per second & Time per scan (ms) \\
    single\_scan0 & 3000 & 1312.85 & 0.76 \\
    single\_scan1 & 3000 & 1237.20 & 0.80 \\
    single\_scan2 & 3000 & 178.85 & 5.59 \\
    single\_scan3 & 3000 & 158.43 & 6.31 \\
    single\_scan4 & 3000 & 97.14 & 10.29 \\
    single\_scan5 & 3000 & 149.45 & 6.69 \\
    single\_scan6 & 3000 & 97.10 & 10.29 \\
    \hline
\end{tabular}
\caption{EC2 p2.xlarge 256 bits
\label{tab:perf-imac-256}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Loops & Total time & Scans per second & Time per scan (ms) \\
    single\_scan0 & 500 & 28.20 & 35.45 \\
    single\_scan1 & 500 & 17.30 & 57.80 \\
    single\_scan2 & 500 & 15.69 & 63.71 \\
    single\_scan3 & 500 & 25.04 & 39.92 \\
    single\_scan4 & 500 & 21.97 & 45.49 \\
    single\_scan5 & 500 & 22.97 & 43.51 \\
    single\_scan6 & 500 & 24.13 & 41.42 \\
    \hline
\end{tabular}
\caption{EC2 p2.xlarge 10k bits
\label{tab:perf-imac-256}}
\end{table}

\begin{figure}[!htb]
\centering\includegraphics[width=\textwidth]{images02/performance/imac-read-256.png}
\caption{Time to run a single read in a SDM with $n=256$, $H=1,000,000$ and $r=103$.
\label{fig:perf-imac-read-256}}
\end{figure}

\begin{figure}[!htb]
\centering\includegraphics[width=\textwidth]{images02/performance/imac-write-256.png}
\caption{Time to run one write in a SDM with $n=256$, $H=1,000,000$ and $r=103$.
\label{fig:perf-imac-write-256}}
\end{figure}

\begin{figure}[!htb]
\centering\includegraphics[width=\textwidth]{images02/performance/imac-write-1000.png}
\caption{Time to run one write in a SDM with $n=1,000$, $H=1,000,000$ and $r=451$.
\label{fig:perf-imac-write-1000}}
\end{figure}

\begin{figure}[!htb]
\centering\includegraphics[width=\textwidth]{images02/performance/imac-read-1000.png}
\caption{Time to run a single read in a SDM with $n=1,000$, $H=1,000,000$ and $r=451$.
\label{fig:perf-imac-read-1000}}
\end{figure}

\begin{figure}[!htb]
\centering\includegraphics[width=\textwidth]{images02/performance/imac-scans-256.png}
\caption{Time to run a single scan in a SDM with $n=256$, $H=1,000,000$ and $r=103$.
\label{fig:perf-imac-scan-256}}
\end{figure}

\begin{figure}[!htb]
\centering\includegraphics[width=\textwidth]{images02/performance/imac-scans-1000.png}
\caption{Time to run a single scan in a SDM with $n=1,000$, $H=1,000,000$ and $r=451$.
\label{fig:perf-imac-scan-1000}}
\end{figure}

\begin{figure}[!htb]
\centering\includegraphics[width=\textwidth]{images02/performance/imac-scans-10k.png}
\caption{Time to run a single scan in a SDM with $n=10,000$, $H=1,000,000$ and $r=4845$.
\label{fig:perf-imac-scan-10k}}
\end{figure}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Linear scan & 1000 & 81.62 & 12.25 \\
    Thread scan & 5000 & 143.68 & 6.95 \\
    OpenCL scan & 5000 & 238.00 & 4.20 \\ \hline
    \hline
    & Loops & Ops / second & Op. time (ms) \\ \hline
    Thread write & 1000 & 74.92 & 13.34 \\
    Thread single read & 1000 & 96.22 & 10.39 \\
    OpenCL write & 1000 & 126.50 & 7.90 \\
    OpenCL single read & 1000 & 190.20 & 5.25 \\
    \hline
\end{tabular}
\caption{iMac Retina 5K 27-inch 2017 with a 3.8GHz Intel core i5 processor, 8GB DDR4 RAM, and a Radeon Pro 580 8G GPU. Running an SDM with $n=1,000$ bits, $H=1,000,000$, and $r=451$.
\label{tab:perf-imac-1000}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Linear scan & 1000 & 175.48 & 5.69 \\
    Thread scan & 5000 & 352.63 & 2.83 \\
    OpenCL scan & 5000 & 244.88 & 4.08 \\ \hline
    \hline
    & Loops & Ops / second & Op. time (ms) \\ \hline
    Thread write & 2000 & 304.46 & 3.28 \\
    Thread single read & 2000 & 391.21 & 2.55 \\
    OpenCL write & 2000 & 378.44 & 2.64 \\
    OpenCL single read & 2000 & 466.16 & 2.14 \\
    \hline
\end{tabular}
\caption{iMac Retina 5K 27-inch 2017 with a 3.8GHz Intel core i5 processor, 8GB DDR4 RAM, and a Radeon Pro 580 8G GPU. Running an SDM with $n=256$ bits, $H=1,000,000$, and $r=103$.
\label{tab:perf-imac-256}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Linear scan & 100 & 8.59 & 116.38 \\
    Thread scan & 500 & 18.66 & 53.56 \\
    OpenCL scan & 1000 & 77.20 & 12.95 \\
    \hline
\end{tabular}
\caption{iMac Retina 5K 27-inch 2017 with a 3.8GHz Intel core i5 processor, 8GB DDR4 RAM, and a Radeon Pro 580 8G GPU. Running an SDM with $n=10,000$ bits, $H=1,000,000$, and $r=4845$.  There is no benchmark for read and write operations because RAM is not enough to allocate the counters --- it would consume 37.25 GB of RAM.
\label{tab:perf-imac-10k}}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Linear scan & 1000 & 15.44 & 64.73 \\
    Thread scan & 5000 & 30.47 & 32.81 \\
    OpenCL scan & 5000 & 93.63 & 10.67 \\ \hline
    \hline
    & Loops & Ops / second & Op. time (ms) \\ \hline
    Thread write & 1000 & 23.44 & 42.64 \\
    Thread single read & 1000 & 28.26 & 35.37 \\
    OpenCL write & 1000 & 51.78 & 19.31 \\
    OpenCL single read & 1000 & 85.31 & 11.72 \\
    \hline
\end{tabular}
\caption{Amazon EC2 p2.xlarge with Intel Xeon E5-2686v4 processor, 61GB DDR3 RAM, and NVIDIA K80 GPU. Running an SDM with $n=1,000$ bits, $H=1,000,000$, and $r=451$.}
\end{table}


\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Linear scan & 1000 & 52.35 & 19.09 \\
    Thread scan & 5000 & 100.48 & 9.95 \\
    OpenCL scan & 5000 & 145.18 & 6.88 \\ \hline
    \hline
    & Loops & Ops / second & Op. time (ms) \\ \hline
    Thread write & 2000 & 84.73 & 11.80 \\
    Thread single read & 2000 & 95.26 & 10.49 \\
    OpenCL write & 2000 & 113.01 & 8.84 \\
    OpenCL single read & 2000 & 133.19 & 7.50 \\
    \hline
\end{tabular}
\caption{Amazon EC2 p2.xlarge with Intel Xeon E5-2686v4 processor, 61GB DDR3 RAM, and NVIDIA K80 GPU. Running an SDM with $n=256$ bits, $H=1,000,000$, and $r=103$.}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Linear scan & 100 & 1.66 & 600.75 \\
    Thread scan & 500 & 3.37 & 296.56 \\
    OpenCL scan & 1000 & 21.39 & 46.73 \\ \hline
    \hline
    & Loops & Ops / second & Op. time (ms) \\ \hline
    Thread write & 500 & 2.60 & 383.50 \\
    Thread single read & 500 & 3.24 & 307.97 \\
    OpenCL write & 1000 & 8.18 & 122.17 \\
    OpenCL single read & 55.47 & 18.02 & 55.47 \\
    \hline
\end{tabular}
\caption{EC p2.xlarge 10,000-bits}
\caption{Amazon EC2 p2.xlarge with Intel Xeon E5-2686v4 processor, 61GB DDR3 RAM, and NVIDIA K80 GPU. Running an SDM with $n=10,000$ bits, $H=1,000,000$, and $r=4845$.}
\end{table}


\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Linear scan & 1000 & 17.13 & 58.34 \\
    Thread scan & 5000 & 60.98 & 16.39 \\
    OpenCL scan & 5000 & 1175.88 & 0.85 \\ \hline
    \hline
    & Loops & Ops / second & Op. time (ms) \\ \hline
    Thread write & 1000 & 35.12 & 28.47 \\
    Thread single read & 1000 & 57.31 & 17.44 \\
    OpenCL write & 1000 & 113.98 & 8.77 \\
    OpenCL single read & 1000 & 549.12 & 1.82 \\
    \hline
\end{tabular}
\caption{Amazon EC2 p3.2xlarge with Intel Xeon E5-2686v4 processor, 488GB DDR3 RAM, and NVIDIA Tesla V100 GPU. Running an SDM with $n=1,000$ bits, $H=1,000,000$, and $r=451$.}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Linear scan & 1000 & 56.80 & 17.60 \\
    Thread scan & 5000 & 192.54 & 5.19 \\
    OpenCL scan & 5000 & 1565.28 & 0.63 \\ \hline
    \hline
    & Loops & Ops / second & Op. time (ms) \\ \hline
    Thread write & 2000 & 131.64 & 7.59 \\
    Thread single read & 2000 & 161.97 & 6.17 \\
    OpenCL write & 2000 & 427.38 & 2.33 \\
    OpenCL single read & 2000 & 987.95 & 1.01 \\
    \hline
\end{tabular}
\caption{Amazon EC2 p3.2xlarge with Intel Xeon E5-2686v4 processor, 488GB DDR3 RAM, and NVIDIA Tesla V100 GPU. Running an SDM with $n=256$ bits, $H=1,000,000$, and $r=103$.}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{| l | r | r | r |}
    \hline
    & Loops & Scans / second & Scan time (ms) \\ \hline
    Linear scan & 100 & 1.84 & 540.97 \\
    Thread scan & 500 & 5.03 & 198.74 \\
    OpenCL scan & 1000 & 174.05 & 5.74 \\ \hline
    \hline
    & Loops & Ops / second & Op. time (ms) \\ \hline
    Thread write & 500 & 4.50 & 222.08 \\
    Thread single read & 500 & 6.89 & 145.01 \\
    OpenCL write & 1000 & 12.42 & 80.48 \\
    OpenCL single read & 1000 & 71.46 & 13.99 \\
    \hline
\end{tabular}
\caption{Amazon EC2 p3.2xlarge with Intel Xeon E5-2686v4 processor, 488GB DDR3 RAM, and NVIDIA Tesla V100 GPU. Running an SDM with $n=10,000$ bits, $H=1,000,000$, and $r=4845$.}
\end{table}
